#!/usr/bin/env bash
set -e

. "$_SUB_ROOT/share/colors.bash"

print_summaries() {
  local commands=()
  local summaries=()
  local longest_command=0
  local command

  for command in $(sub-commands --no-color); do
    local file="$(command_path "$command")"
    if [ ! -h "$file" ]; then
      local summary="$(summary "$file")"
      if [ -n "$summary" ]; then
        commands["${#commands[@]}"]="$command"
        summaries["${#summaries[@]}"]=$(eval echo $summary)

        if [ "${#command}" -gt "$longest_command" ]; then
          longest_command="${#command}"
        fi
      fi
    fi
  done

  local index
  local columns="$(tput cols)"
  local summary_length=$(( $columns - $longest_command - 5 ))

  for (( index=0; index < ${#commands[@]}; index++ )); do
    printf "   "`clr_yellow "%-${longest_command}s"`"  %s\n" "${commands[$index]}" \
      "$(truncate "$summary_length" "${summaries[$index]}")"
  done
}

print_help() {
  local file="$1"
  local cmd=$2
  local usage="$(usage "$file")"

  if [ -n "$usage" ]; then
    echo $(eval echo $usage)

    local help="$(help "$file")"
    [ -n "$help" ] && echo && echo $(eval echo $help)
  else
    echo "Sorry, the \`${cmd}\` command isn't documented yet."
    echo "You might consider adding documentation to ${file}"
  fi
}

command_path() {
  command -v "${SUB_COMMAND_PREFIX}-$command" || command -v "${SUB_COMMAND_PREFIX}-sh-$command" || true
}

summary() {
  sed -n "s/^# Summary: \(.*\)/\1/p" "$1"
}

usage() {
  sed -n "s/^# \(Usage: .*\)/\1/p" "$1"
}

help() {
  awk '/^[^#]/{p=0} /^# Help:/{p=1} p' "$1" | sed "s/^# Help: //;s/^# //;s/^#//"
}

truncate() {
  local max_length="$1"
  local string="$2"

  if [ "${#string}" -gt "$max_length" ]; then
    local length=$(( $max_length - 3 ))
    echo "${string:0:$length}..."
  else
    echo "$string"
  fi
}

# Provide sub completions
if [ "$1" = "--complete" ]; then
  exec "sub-commands"
  exit
fi

command="$1"
case "$command" in
"" | "-h" | "--help" | "help")
    echo "Usage: ${SUB_COMMAND_NAME} <command> [<args>]

    Some useful ${SUB_COMMAND_NAME} commands are:
    $(print_summaries)

    See '${SUB_COMMAND_NAME} <command> --help' for information on a specific command."
    ;;
*)
  file="$(command_path "$command")"

  if [ -n "$file" ]; then
    print_help "$file" "$command"
  else
    echo "${SUB_COMMAND_NAME}: no such command \`$command\`" >&2
    exit 1
  fi
esac
