#!/usr/bin/env bash
# SOURCE

[ -z ${_SUB_ROOT+x} ] && export _SUB_ROOT="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && cd .. && pwd )"

export SUB_LIB_PATH="$_SUB_ROOT/libexec"

. "$_SUB_ROOT/lib/doc_parse.bash"

# determine if a sub-command is a source command
_is_source_sub() {
    local out=`grep $'#[ \t]*SOURCE' $1`
    if [ "$out" == "" ]; then
        echo "0"
        return
    fi
    echo "1"
}

function sub_command_main() {
    local original_path=$PATH
    local is_source_command=0
    export PATH="$SUB_COMMAND_PATH:$SUB_LIB_PATH:$PATH"

    # todo: add config based option parsing and long > short option translation
    # see: http://stackoverflow.com/questions/12022592/how-can-i-use-long-options-with-the-bash-getopts-builtin

    last_arg="${@: -1}"
    if [[ "$last_arg" = "-h" || "$last_arg" = "--help" || "$last_arg" = "help" || -z "$1" ]]; then
        sub_command="help"
    else
        sub_command="$1"
        shift
    fi

    command_path="$(get_command_path "$sub_command")"

    if [[ ! -x "$command_path" ]]; then
        if [[ -r "$SUB_COMMAND_PATH/_alias" ]]; then
            IFS="="
            while read -r name value; do
                if [[ "$sub_command" == "$name" ]]; then
                    value="${value%\"}"
                    value="${value#\"}"
                    eval "${value} $@"
                    export PATH=$original_path
                    exit
                fi
              #   echo "Content of $name is ${value//\"/}"
            done < "$SUB_COMMAND_PATH/_alias"
        fi
        echo "${SUB_COMMAND_NAME}: unknown command \`$sub_command\`"
    else
        is_source_command=$(_is_source_sub $command_path)

        if [[ "$is_source_command" -eq 1 && "${sub_command}" != "--complete" ]]; then
            . $command_path "$@"
        else
            $command_path "$@" "$CWORDS"
        fi
    fi
    export PATH=$original_path
}
